{"version":3,"sources":["../../../src/frameworks/apollo-server/apollo-server.framework.ts"],"sourcesContent":["//#region\n\nimport type { IncomingMessage, ServerResponse } from 'http';\nimport { type ApolloServer, type BaseContext, HeaderMap } from '@apollo/server';\nimport type { FrameworkContract } from '../../contracts';\nimport { ServerlessRequest } from '../../network';\nimport { getDefaultIfUndefined } from '../../core';\n\n//#endregion\n\n/**\n * The default context of Apollo Server when you integrate and don't pass any context.\n *\n * @breadcrumb Frameworks / ApolloServerFramework\n * @public\n */\nexport interface DefaultServerlessApolloServerContext extends BaseContext {\n  /**\n   * The request reference\n   */\n  request: IncomingMessage;\n  /**\n   * The response reference\n   */\n  response: ServerResponse;\n}\n\n/**\n * The arguments used to create a Context inside {@link ApolloServerOptions}\n *\n * @breadcrumb Frameworks / ApolloServerFramework\n * @public\n */\nexport type ApolloServerContextArguments = {\n  /**\n   * The request reference\n   */\n  request: IncomingMessage;\n  /**\n   * The response reference\n   */\n  response: ServerResponse;\n};\n\n/**\n * The options to customize {@link ApolloServerFramework}\n *\n * @breadcrumb Frameworks / ApolloServerFramework\n * @public\n */\nexport interface ApolloServerOptions<TContext extends BaseContext> {\n  /**\n   * Define a function to create the context of Apollo Server\n   *\n   * @param options - Default options passed by library\n   */\n  context?: (options: ApolloServerContextArguments) => Promise<TContext>;\n}\n\n/**\n * The framework that forwards requests to Apollo Server\n *\n * @breadcrumb Frameworks / ApolloServerFramework\n * @public\n */\nexport class ApolloServerFramework<TContext extends BaseContext>\n  implements FrameworkContract<ApolloServer<TContext>>\n{\n  //#region Constructor\n\n  /**\n   * Construtor padr√£o\n   */\n  constructor(protected readonly options?: ApolloServerOptions<TContext>) {}\n\n  //#endregion\n\n  /**\n   * {@inheritDoc}\n   */\n  public sendRequest(\n    app: ApolloServer<TContext>,\n    request: ServerlessRequest,\n    response: ServerResponse,\n  ): void {\n    const headers = new HeaderMap();\n\n    for (const [key, value] of Object.entries(request.headers)) {\n      if (value === undefined) continue;\n\n      headers.set(\n        key,\n        Array.isArray(value) ? value.join(', ') : value.toString(),\n      );\n    }\n\n    const defaultContext: ApolloServerOptions<any>['context'] = context =>\n      Promise.resolve(context);\n\n    const context = () =>\n      getDefaultIfUndefined(\n        this.options?.context,\n        defaultContext,\n      )({ request, response });\n\n    const search = request.url?.startsWith('http')\n      ? new URL(request.url).search ?? ''\n      : request.url?.split('?')[1] || '';\n\n    // we don't need to handle catch because of https://www.apollographql.com/docs/apollo-server/integrations/building-integrations/#handle-errors\n    app\n      .executeHTTPGraphQLRequest({\n        httpGraphQLRequest: {\n          method: request.method!.toUpperCase(),\n          headers,\n          body: request.body,\n          search,\n        },\n        context,\n      })\n      .then(async httpGraphQLResponse => {\n        // this section was copy and pasted from https://github.com/apollographql/apollo-server/blob/main/packages/server/src/express4/index.ts#L95\n\n        for (const [key, value] of httpGraphQLResponse.headers)\n          response.setHeader(key, value);\n\n        response.statusCode = httpGraphQLResponse.status || 200;\n\n        if (httpGraphQLResponse.body.kind === 'complete') {\n          response.end(httpGraphQLResponse.body.string);\n          return;\n        }\n\n        for await (const chunk of httpGraphQLResponse.body.asyncIterator) {\n          response.write(chunk);\n          // Express/Node doesn't define a way of saying \"it's time to send this\n          // data over the wire\"... but the popular `compression` middleware\n          // (which implements `accept-encoding: gzip` and friends) does, by\n          // monkey-patching a `flush` method onto the response. So we call it\n          // if it's there.\n          if (typeof (response as any).flush === 'function')\n            (response as any).flush();\n        }\n\n        response.end();\n      });\n  }\n}\n"],"mappings":"0FAGA,OAA8C,aAAAA,MAAiB,iBA8DxD,IAAMC,EAAN,KAEP,CAME,YAA+BC,EAAyC,CAAzC,aAAAA,CAA0C,CAzE3E,MAmEA,CAAAC,EAAA,8BAaS,YACLC,EACAC,EACAC,EACM,CACN,IAAMC,EAAU,IAAIC,EAEpB,OAAW,CAACC,EAAKC,CAAK,IAAK,OAAO,QAAQL,EAAQ,OAAO,EACnDK,IAAU,QAEdH,EAAQ,IACNE,EACA,MAAM,QAAQC,CAAK,EAAIA,EAAM,KAAK,IAAI,EAAIA,EAAM,SAAS,CAC3D,EAGF,IAAMC,EAAsDR,EAAAS,GAC1D,QAAQ,QAAQA,CAAO,EADmC,kBAGtDA,EAAUT,EAAA,IACdU,EACE,KAAK,SAAS,QACdF,CACF,EAAE,CAAE,QAAAN,EAAS,SAAAC,CAAS,CAAC,EAJT,WAMVQ,EAAST,EAAQ,KAAK,WAAW,MAAM,EACzC,IAAI,IAAIA,EAAQ,GAAG,EAAE,QAAU,GAC/BA,EAAQ,KAAK,MAAM,GAAG,EAAE,CAAC,GAAK,GAGlCD,EACG,0BAA0B,CACzB,mBAAoB,CAClB,OAAQC,EAAQ,OAAQ,YAAY,EACpC,QAAAE,EACA,KAAMF,EAAQ,KACd,OAAAS,CACF,EACA,QAAAF,CACF,CAAC,EACA,KAAK,MAAMG,GAAuB,CAGjC,OAAW,CAACN,EAAKC,CAAK,IAAKK,EAAoB,QAC7CT,EAAS,UAAUG,EAAKC,CAAK,EAI/B,GAFAJ,EAAS,WAAaS,EAAoB,QAAU,IAEhDA,EAAoB,KAAK,OAAS,WAAY,CAChDT,EAAS,IAAIS,EAAoB,KAAK,MAAM,EAC5C,MACF,CAEA,cAAiBC,KAASD,EAAoB,KAAK,cACjDT,EAAS,MAAMU,CAAK,EAMhB,OAAQV,EAAiB,OAAU,YACpCA,EAAiB,MAAM,EAG5BA,EAAS,IAAI,CACf,CAAC,CACL,CACF","names":["HeaderMap","ApolloServerFramework","options","__name","app","request","response","headers","HeaderMap","key","value","defaultContext","context","getDefaultIfUndefined","search","httpGraphQLResponse","chunk"]}