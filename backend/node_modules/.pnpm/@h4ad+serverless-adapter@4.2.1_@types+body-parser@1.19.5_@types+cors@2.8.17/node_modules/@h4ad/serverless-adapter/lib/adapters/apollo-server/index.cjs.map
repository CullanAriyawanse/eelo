{"version":3,"sources":["../../../src/adapters/apollo-server/index.ts","../../../src/network/request.ts","../../../src/network/response.ts","../../../src/network/utils.ts","../../../src/network/response-stream.ts","../../../src/core/event-body.ts","../../../src/core/no-op.ts","../../../src/core/logger.ts","../../../src/core/optional.ts","../../../src/core/stream.ts","../../../src/adapters/apollo-server/apollo-server-mutation.adapter.ts"],"sourcesContent":["export * from './apollo-server-mutation.adapter';\n","// ATTRIBUTION: https://github.com/dougmoscrop/serverless-http\nimport { IncomingMessage } from 'node:http';\nimport type { AddressInfo } from 'node:net';\nimport type { SingleValueHeaders } from '../@types';\nimport { NO_OP } from '../core';\n\nconst HTTPS_PORT = 443;\n\n/**\n * The properties to create a {@link ServerlessRequest}\n *\n * @breadcrumb Network / ServerlessRequest\n * @public\n */\nexport interface ServerlessRequestProps {\n  /**\n   * The HTTP Method of the request\n   */\n  method: string;\n\n  /**\n   * The URL requested\n   */\n  url: string;\n\n  /**\n   * The headers from the event source\n   */\n  headers: SingleValueHeaders;\n\n  /**\n   * The body from the event source\n   */\n  body?: Buffer | Uint8Array;\n\n  /**\n   * The IP Address from caller\n   */\n  remoteAddress?: string;\n}\n\n/**\n * The class that represents an {@link http#IncomingMessage} created by the library to represent an actual request to the framework.\n *\n * @breadcrumb Network / ServerlessRequest\n * @public\n */\nexport class ServerlessRequest extends IncomingMessage {\n  constructor({\n    method,\n    url,\n    headers,\n    body,\n    remoteAddress,\n  }: ServerlessRequestProps) {\n    super({\n      encrypted: true,\n      readable: false,\n      remoteAddress,\n      address: () => ({ port: HTTPS_PORT }) as AddressInfo,\n      end: NO_OP,\n      destroy: NO_OP,\n    } as any);\n\n    this.statusCode = 200;\n    this.statusMessage = 'OK';\n    this.complete = true;\n    this.httpVersion = '1.1';\n    this.httpVersionMajor = 1;\n    this.httpVersionMinor = 1;\n    this.method = method;\n    this.headers = headers;\n    this.body = body;\n    this.url = url;\n    this.ip = remoteAddress;\n\n    this._read = () => {\n      this.push(body);\n      this.push(null);\n    };\n  }\n\n  ip?: string;\n  body?: Buffer | Uint8Array;\n}\n","// ATTRIBUTION: https://github.com/dougmoscrop/serverless-http\nimport { IncomingMessage, ServerResponse } from 'node:http';\nimport type { Socket } from 'node:net';\nimport { NO_OP } from '../core';\nimport { getString } from './utils';\n\nconst headerEnd = '\\r\\n\\r\\n';\nconst endChunked = '0\\r\\n\\r\\n';\n\nconst BODY = Symbol('Response body');\nconst HEADERS = Symbol('Response headers');\n\nfunction addData(stream: ServerlessResponse, data: Uint8Array | string) {\n  if (\n    Buffer.isBuffer(data) ||\n    typeof data === 'string' ||\n    data instanceof Uint8Array\n  )\n    stream[BODY].push(Buffer.from(data));\n  else throw new Error(`response.write() of unexpected type: ${typeof data}`);\n}\n\n/**\n * The properties to create a {@link ServerlessResponse}.\n *\n * @breadcrumb Network / ServerlessResponse\n * @public\n */\nexport interface ServerlessResponseProps {\n  /**\n   * The HTTP Method from request\n   */\n  method?: string;\n}\n\n/**\n * The class that represents a response instance used to send to the framework and wait until the framework finishes processing the request.\n * Once it's happens, we use the properties from this response to built the response to the cloud.\n *\n * @breadcrumb Network / ServerlessResponse\n * @public\n */\nexport class ServerlessResponse extends ServerResponse {\n  constructor({ method }: ServerlessResponseProps) {\n    super({ method } as any);\n\n    this[BODY] = [];\n    this[HEADERS] = {};\n\n    this.useChunkedEncodingByDefault = false;\n    this.chunkedEncoding = false;\n    this._header = '';\n\n    // this ignore is used because I need to ignore these write calls:\n    // https://github.com/nodejs/node/blob/main/lib/_http_outgoing.js#L934-L935\n    // https://github.com/nodejs/node/blob/main/lib/_http_outgoing.js#L937\n    let writesToIgnore = 1;\n\n    const socket: Partial<Socket> & { _writableState: any } = {\n      _writableState: {},\n      writable: true,\n      on: NO_OP,\n      removeListener: NO_OP,\n      destroy: NO_OP,\n      cork: NO_OP,\n      uncork: NO_OP,\n      write: (\n        data: Uint8Array | string,\n        encoding?: string | null | (() => void),\n        cb?: () => void,\n      ): any => {\n        if (typeof encoding === 'function') {\n          cb = encoding;\n          encoding = null;\n        }\n\n        if (this._header === '' || this._wroteHeader) {\n          if (!this.chunkedEncoding) addData(this, data);\n          else {\n            if (writesToIgnore > 0) writesToIgnore--;\n            else if (data !== endChunked) {\n              addData(this, data);\n              writesToIgnore = 3;\n            }\n          }\n        } else {\n          const string = getString(data);\n          const index = string.indexOf(headerEnd);\n\n          if (index !== -1) {\n            const remainder = string.slice(index + headerEnd.length);\n\n            if (remainder && !this.chunkedEncoding) addData(this, remainder);\n\n            this._wroteHeader = true;\n          }\n        }\n\n        if (typeof cb === 'function') cb();\n      },\n    };\n\n    this.assignSocket(socket as unknown as Socket);\n  }\n\n  _header: string;\n  _headers?: Record<any, any>;\n  _wroteHeader?: boolean;\n\n  [BODY]: any[];\n  [HEADERS]: Record<any, any>;\n\n  get headers(): Record<any, any> {\n    return this[HEADERS];\n  }\n\n  static from(res: IncomingMessage) {\n    const response = new ServerlessResponse({ method: res.method });\n\n    response.statusCode = res.statusCode || 0;\n    response[HEADERS] = res.headers;\n    response[BODY] = (res as any).body ? [Buffer.from((res as any).body)] : [];\n    response.end();\n\n    return response;\n  }\n\n  static body(res: ServerlessResponse): Buffer {\n    return Buffer.concat(res[BODY]);\n  }\n\n  static headers(res: ServerlessResponse) {\n    const headers = res.getHeaders();\n\n    return Object.assign(headers, res[HEADERS]);\n  }\n\n  override setHeader(\n    key: string,\n    value: number | string | readonly string[],\n  ): any {\n    if (this._wroteHeader) this[HEADERS][key] = value;\n    else super.setHeader(key, value);\n  }\n\n  override writeHead(\n    statusCode: number,\n    statusMessage?: string | any | any[],\n    obj?: any | any[],\n  ): any {\n    const headersObjOrArray =\n      typeof statusMessage === 'string' ? obj : statusMessage;\n\n    const arrayHeaders = Array.isArray(headersObjOrArray)\n      ? headersObjOrArray\n      : [headersObjOrArray || {}];\n\n    for (const headers of arrayHeaders) {\n      for (const name in headers) {\n        this.setHeader(name, headers[name]!);\n\n        if (!this._wroteHeader) {\n          // we only need to initiate super.headers once\n          // writeHead will add the other headers itself\n          break;\n        }\n      }\n    }\n\n    return this.callNativeWriteHead(statusCode, statusMessage, obj);\n  }\n\n  /**\n   * I use ignore here because in nodejs 12.x, statusMessage can be string | OutgoingHttpHeaders\n   * But in nodejs \\>=14.x, statusMessage can also be OutgoingHttpHeaders[]\n   * I take care of these cases above, but here I can't handle it well, so I give up\n   * nodejs 12.x ref: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/v12/http.d.ts#L229\n   * nodejs 14.x ref: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/v14/http.d.ts#L263\n   */\n  protected callNativeWriteHead(\n    statusCode: number,\n    statusMessage?: string | any | any[],\n    obj?: any | any[],\n  ): this {\n    return super.writeHead(statusCode, statusMessage, obj);\n  }\n}\n","/**\n * Get the data from a buffer, string, or Uint8Array\n *\n * @breadcrumb Network\n * @param data - The data that was written inside the stream\n */\nexport function getString(data: Buffer | string | unknown) {\n  if (Buffer.isBuffer(data)) return data.toString('utf8');\n  else if (typeof data === 'string') return data;\n  else if (data instanceof Uint8Array) return new TextDecoder().decode(data);\n  else throw new Error(`response.write() of unexpected type: ${typeof data}`);\n}\n","import { ServerResponse } from 'node:http';\nimport type { Socket } from 'node:net';\nimport type { Writable } from 'node:stream';\nimport type { BothValueHeaders } from '../@types';\nimport { type ILogger, NO_OP, parseHeaders } from '../core';\nimport { getString } from './utils';\n\nconst endChunked = '0\\r\\n\\r\\n';\nconst headerEnd = '\\r\\n\\r\\n';\nconst endStatusSeparator = '\\r\\n';\n\n/**\n * The properties to create a {@link ServerlessStreamResponse}.\n *\n * @breadcrumb Network / ServerlessStreamResponse\n * @public\n */\nexport interface ServerlessStreamResponseProps {\n  /**\n   * The HTTP Method from request\n   */\n  method?: string;\n\n  /**\n   * The callback to receive the headers when they are written to the stream\n   * You need to return a writable stream be able to continue writing the response\n   *\n   * @param statusCode - The status code of the response\n   * @param headers - The headers of the response\n   */\n  onReceiveHeaders: (statusCode: number, headers: BothValueHeaders) => Writable;\n\n  /**\n   * Instance of the logger\n   */\n  log: ILogger;\n}\n\n/**\n * The class that represents a response instance used to send to the framework and wait until the framework finishes processing the request.\n * This response is specially built to deal with transfer-encoding: chunked\n *\n * @breadcrumb Network / ServerlessStreamResponse\n * @public\n */\nexport class ServerlessStreamResponse extends ServerResponse {\n  constructor({\n    method,\n    onReceiveHeaders,\n    log,\n  }: ServerlessStreamResponseProps) {\n    super({ method } as any);\n\n    this.useChunkedEncodingByDefault = true;\n    this.chunkedEncoding = true;\n\n    let internalWritable: Writable | null = null;\n    let isFirstCall = true;\n    // this ignore is used because I need to ignore these write calls:\n    // https://github.com/nodejs/node/blob/main/lib/_http_outgoing.js#L934-L935\n    // https://github.com/nodejs/node/blob/main/lib/_http_outgoing.js#L937\n    let writesToIgnore = 0;\n\n    const socket: Partial<Socket> & { _writableState: any } = {\n      _writableState: {},\n      writable: true,\n      on: NO_OP,\n      removeListener: NO_OP,\n      destroy: NO_OP,\n      cork: NO_OP,\n      uncork: NO_OP,\n      write: (\n        data: Uint8Array | string,\n        encoding?: string | null | (() => void),\n        cb?: () => void,\n      ): any => {\n        // very unlikely, I don't even know how to reproduce this, but exist on types\n        // istanbul ignore if\n        if (typeof encoding === 'function') {\n          cb = encoding;\n          encoding = null;\n        }\n\n        log.debug('SERVERLESS_ADAPTER:RESPONSE_STREAM:DATA', () => ({\n          data: Buffer.isBuffer(data) ? data.toString('utf8') : data,\n          encoding,\n        }));\n\n        if (!isFirstCall && internalWritable) {\n          if (data === endChunked) {\n            internalWritable.end(cb);\n\n            return true;\n          }\n\n          if (writesToIgnore > 0) {\n            writesToIgnore--;\n            return true;\n          }\n\n          internalWritable.write(data, cb);\n          writesToIgnore = 3;\n        } else if (isFirstCall) {\n          isFirstCall = false;\n\n          const stringData = getString(data);\n          const endStatusIndex = stringData.indexOf(endStatusSeparator);\n          const status = +stringData.slice(0, endStatusIndex).split(' ')[1];\n          const endHeaderIndex = stringData.indexOf(headerEnd);\n\n          const headerData = stringData.slice(\n            endStatusIndex + 2,\n            endHeaderIndex,\n          );\n          const headers = parseHeaders(headerData);\n          log.debug(\n            'SERVERLESS_ADAPTER:RESPONSE_STREAM:FRAMEWORK_HEADERS',\n            () => ({\n              headers,\n            }),\n          );\n\n          writesToIgnore = 1;\n          internalWritable = onReceiveHeaders(status, headers);\n\n          // If we get an endChunked right after header which means the response body is empty, we need to immediately end the writable\n          if (stringData.substring(endHeaderIndex + 4) === endChunked)\n            internalWritable.end();\n        }\n\n        return true;\n      },\n    };\n\n    this.assignSocket(socket as unknown as Socket);\n  }\n}\n","/**\n * Get the event body as buffer from body string with content length\n *\n * @example\n * ```typescript\n * const body = '{}';\n * const [buffer, contentLength] = getEventBodyAsBuffer(body, false);\n * console.log(buffer);\n * // <Buffer 7b 7d>\n * console.log(contentLength);\n * // 2\n * ```\n *\n * @param body - The body string that can be encoded or not\n * @param isBase64Encoded - Tells if body string is encoded in base64\n *\n * @breadcrumb Core\n * @public\n */\nexport function getEventBodyAsBuffer(\n  body: string,\n  isBase64Encoded: boolean,\n): [body: Buffer, contentLength: number] {\n  const encoding: BufferEncoding = isBase64Encoded ? 'base64' : 'utf8';\n\n  const buffer = Buffer.from(body, encoding);\n  const contentLength = Buffer.byteLength(buffer, encoding);\n\n  return [buffer, contentLength];\n}\n","/**\n * No operation function is used when we need to pass a function, but we don't want to specify any behavior.\n *\n * @breadcrumb Core\n * @public\n */\nexport const NO_OP: (...args: any[]) => any = () => void 0;\n","import { NO_OP } from './no-op';\n\n/**\n * The type representing the possible log levels to choose from.\n *\n * @breadcrumb Core / Logger\n * @public\n */\nexport type LogLevels =\n  | 'debug'\n  | 'verbose'\n  | 'info'\n  | 'warn'\n  | 'error'\n  | 'none';\n\n/**\n * The options to customize {@link ILogger}\n *\n * @breadcrumb Core / Logger\n * @public\n */\nexport type LoggerOptions = {\n  /**\n   * Select the log level, {@link LogLevels | see more}.\n   *\n   * @defaultValue error\n   */\n  level: LogLevels;\n};\n\n/**\n * The log function used in any level.\n *\n * @breadcrumb Core / Logger\n * @public\n */\nexport type LoggerFN = (message: any, ...additional: any[]) => void;\n\n/**\n * The interface representing the logger, you can provide a custom logger by implementing this interface.\n *\n * @breadcrumb Core / Logger\n * @public\n */\nexport type ILogger = Record<Exclude<LogLevels, 'none'>, LoggerFN>;\n\n/**\n * The symbol used to check against an ILogger instace to verify if that ILogger was created by this library\n *\n * @breadcrumb Core / Logger\n * @public\n */\nconst InternalLoggerSymbol = Symbol('InternalLogger');\n\nconst logLevels: Record<\n  LogLevels,\n  [level: LogLevels, consoleMethod: keyof Console][]\n> = {\n  debug: [\n    ['debug', 'debug'],\n    ['verbose', 'debug'],\n    ['info', 'info'],\n    ['error', 'error'],\n    ['warn', 'warn'],\n  ],\n  verbose: [\n    ['verbose', 'debug'],\n    ['info', 'info'],\n    ['error', 'error'],\n    ['warn', 'warn'],\n  ],\n  info: [\n    ['info', 'info'],\n    ['error', 'error'],\n    ['warn', 'warn'],\n  ],\n  warn: [\n    ['warn', 'warn'],\n    ['error', 'error'],\n  ],\n  error: [['error', 'error']],\n  none: [],\n};\n\nconst lazyPrint = (value: () => any | unknown) => {\n  if (typeof value === 'function') return value();\n\n  return value;\n};\n\nconst print =\n  (fn: string) =>\n  (message: any, ...additional: (() => any)[]) =>\n    console[fn](message, ...additional.map(lazyPrint));\n\n/**\n * The method used to create a simple logger instance to use in this library.\n *\n * @remarks Behind the scenes, this simple logger sends the message to the `console` methods.\n *\n * @example\n * ```typescript\n * const logger = createDefaultLogger();\n *\n * logger.error('An error happens.');\n * // An error happens.\n * ```\n *\n * @param level - Select the level of the log\n *\n * @breadcrumb Core / Logger\n * @public\n */\nexport function createDefaultLogger(\n  { level }: LoggerOptions = { level: 'error' },\n): ILogger {\n  const levels = logLevels[level];\n\n  if (!levels) throw new Error('Invalid log level');\n\n  const logger = {\n    [InternalLoggerSymbol]: true,\n    error: NO_OP,\n    debug: NO_OP,\n    info: NO_OP,\n    verbose: NO_OP,\n    warn: NO_OP,\n  } as ILogger;\n\n  for (const [level, consoleMethod] of levels)\n    logger[level] = print(consoleMethod);\n\n  return logger;\n}\n\n/**\n * The method used to chck if logger was created by this library, or it was defined by the user.\n *\n * @param logger - The instance of the logger to check\n *\n * @breadcrumb Core / Logger\n * @public\n */\nexport function isInternalLogger(logger: ILogger): boolean {\n  return !!logger[InternalLoggerSymbol];\n}\n","/**\n * Return the defaultValue whether the value is undefined, otherwise, return the value.\n *\n * @example\n * ```typescript\n * const value1 = getDefaultIfUndefined(undefined, true);\n * const value2 = getDefaultIfUndefined(false, true);\n *\n * console.log(value1);\n * // true\n * console.log(value2);\n * // false\n * ```\n *\n * @param value - The value to be checked\n * @param defaultValue - The default value when value is undefined\n *\n * @breadcrumb Core\n * @public\n */\nexport function getDefaultIfUndefined<T>(\n  value: T | undefined,\n  defaultValue: T,\n): T {\n  if (value === undefined) return defaultValue;\n\n  return value;\n}\n","//#region Imports\n\nimport { Readable, Writable } from 'node:stream';\n\n//#endregion\n\n/**\n * Check if stream already ended\n *\n * @param stream - The stream\n *\n * @breadcrumb Core / Stream\n * @public\n */\nexport function isStreamEnded(stream: Readable | Writable): boolean {\n  if ('readableEnded' in stream && stream.readableEnded) return true;\n\n  if ('writableEnded' in stream && stream.writableEnded) return true;\n\n  return false;\n}\n\n/**\n * Wait asynchronous the stream to complete\n *\n * @param stream - The stream\n *\n * @breadcrumb Core / Stream\n * @public\n */\nexport function waitForStreamComplete<TStream extends Readable | Writable>(\n  stream: TStream,\n): Promise<TStream> {\n  if (isStreamEnded(stream)) return Promise.resolve(stream);\n\n  return new Promise<TStream>((resolve, reject) => {\n    // Reading the {@link https://github.com/nodejs/node/blob/v12.22.9/lib/events.js#L262 | emit source code},\n    // it's almost impossible to complete being called twice because the emit function runs synchronously and removes the other listeners,\n    // but I'll leave it at that because I didn't write that code, so I couldn't figure out what the author thought when he wrote this.\n    let isComplete = false;\n\n    function complete(err: any) {\n      /* istanbul ignore next */\n      if (isComplete) return;\n\n      isComplete = true;\n\n      stream.removeListener('error', complete);\n      stream.removeListener('end', complete);\n      stream.removeListener('finish', complete);\n\n      if (err) reject(err);\n      else resolve(stream);\n    }\n\n    stream.once('error', complete);\n    stream.once('end', complete);\n    stream.once('finish', complete);\n  });\n}\n","//#region Imports\n\nimport type {\n  AdapterContract,\n  AdapterRequest,\n  GetResponseAdapterProps,\n  OnErrorProps,\n} from '../../contracts';\nimport {\n  type ILogger,\n  getDefaultIfUndefined,\n  getEventBodyAsBuffer,\n} from '../../core';\n\n//#endregion\n\n/**\n * The options for {@link ApolloServerMutationAdapter}\n *\n * @breadcrumb Adapters / Apollo Server / ApolloServerMutationAdapter\n * @public\n */\nexport type ApolloServerMutationAdapterOptions = {\n  /**\n   * Specify the name of mutation that will be called when an event was received\n   */\n  mutationName: string;\n\n  /**\n   * Specify the mutation result schema.\n   * Use this to customize the behavior when you need to return a specific object to be handled by the Adapter, like SQS with Batch Mode.\n   *\n   * @defaultValue `{ __typename }`\n   */\n  mutationResultQuery?: string;\n};\n\n/**\n * The adapter that wraps another adapter to force a transformation of the event data as a mutation to Apollo Server be able to handle.\n *\n * @breadcrumb Adapters / Apollo Server / ApolloServerMutationAdapter\n * @public\n */\nexport class ApolloServerMutationAdapter<TEvent, TContext, TResponse>\n  implements AdapterContract<TEvent, TContext, TResponse>\n{\n  //#region Constructor\n\n  /**\n   * The default constructor\n   */\n  constructor(\n    protected readonly baseAdapter: AdapterContract<\n      TEvent,\n      TContext,\n      TResponse\n    >,\n    protected readonly options: ApolloServerMutationAdapterOptions,\n  ) {}\n\n  //#endregion\n\n  //#region Public Methods\n\n  /**\n   * {@inheritDoc}\n   */\n  public canHandle(event: unknown, context: TContext, log: ILogger): boolean {\n    return this.baseAdapter.canHandle(event, context, log);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  public getAdapterName(): string {\n    return this.baseAdapter.getAdapterName() + 'Mutation';\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  public getRequest(\n    event: TEvent,\n    context: TContext,\n    log: ILogger,\n  ): AdapterRequest {\n    const request = this.baseAdapter.getRequest(event, context, log);\n\n    request.method = 'POST';\n\n    const operationName = this.options.mutationName;\n    const mutationResultQuery = getDefaultIfUndefined(\n      this.options.mutationResultQuery,\n      '{ __typename }',\n    );\n\n    const mutationBody = JSON.stringify({\n      operationName,\n      query: `mutation ${operationName} ($event: String) { ${operationName} (event: $event) ${mutationResultQuery} }`,\n      variables: {\n        event: request.body?.toString() || '',\n      },\n    });\n\n    const [buffer, contentLength] = getEventBodyAsBuffer(mutationBody, false);\n\n    request.body = buffer;\n    request.headers['content-type'] = 'application/json';\n    request.headers['content-length'] = String(contentLength);\n\n    return request;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  public getResponse(props: GetResponseAdapterProps<TEvent>): TResponse {\n    const { data, errors } = JSON.parse(props.body);\n\n    if (!errors) {\n      return this.baseAdapter.getResponse({\n        ...props,\n        body: JSON.stringify(data[this.options.mutationName]),\n      });\n    }\n\n    // when error happens, is the responsability of base adapter\n    // to deal with error status code.\n    return this.baseAdapter.getResponse(props);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  public onErrorWhileForwarding(props: OnErrorProps<TEvent, TResponse>): void {\n    return this.baseAdapter.onErrorWhileForwarding(props);\n  }\n\n  //#endregion\n}\n"],"mappings":"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","names":["apollo_server_exports","__export","ApolloServerMutationAdapter","__toCommonJS","import_node_http","import_node_http","getString","data","__name","headerEnd","endChunked","BODY","HEADERS","addData","stream","data","__name","ServerlessResponse","_ServerlessResponse","method","writesToIgnore","socket","NO_OP","encoding","cb","string","getString","index","remainder","res","response","headers","key","value","statusCode","statusMessage","obj","headersObjOrArray","arrayHeaders","name","import_node_http","getEventBodyAsBuffer","body","isBase64Encoded","encoding","buffer","contentLength","__name","NO_OP","__name","InternalLoggerSymbol","getDefaultIfUndefined","value","defaultValue","__name","import_node_stream","ApolloServerMutationAdapter","baseAdapter","options","__name","event","context","log","request","operationName","mutationResultQuery","getDefaultIfUndefined","mutationBody","buffer","contentLength","getEventBodyAsBuffer","props","data","errors"]}