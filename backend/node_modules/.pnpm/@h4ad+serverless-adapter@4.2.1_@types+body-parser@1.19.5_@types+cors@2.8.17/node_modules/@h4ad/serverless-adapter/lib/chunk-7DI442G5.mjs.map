{"version":3,"sources":["../src/handlers/base/raw-request.ts"],"sourcesContent":["//#region Imports\n\nimport type { IncomingMessage, ServerResponse } from 'http';\nimport type { FrameworkContract } from '../../contracts';\nimport { ServerlessRequest } from '../../network';\nimport { getEventBodyAsBuffer, getFlattenedHeadersMap } from '../../core';\n\n//#endregion\n\n/**\n * The class that expose some methods to be used to get raw request from Express HTTP Request\n *\n * @breadcrumb Handlers / Base / RawRequest\n * @public\n */\nexport abstract class RawRequest<TApp> {\n  //#region Protected Methods\n\n  /**\n   * The callback to when receive some request from external source\n   *\n   * @param app - The instance of the app\n   * @param framework - The framework for the app\n   */\n  protected onRequestCallback(\n    app: TApp,\n    framework: FrameworkContract<TApp>,\n  ): (req: IncomingMessage, res: ServerResponse) => void | Promise<void> {\n    return (request: IncomingMessage, response: ServerResponse) => {\n      const customRequest = this.getRequestFromExpressRequest(request);\n\n      return framework.sendRequest(app, customRequest, response);\n    };\n  }\n\n  /**\n   * Not sure why they think using Express instance with prebuilt middlewares was a good idea, but Firebase/GCP\n   * decides to use `Express` and `body-parser` by default, so you don't get a raw request, instead, you get a modified version by\n   * Express and also with the body parsed by `body-parser`.\n   * If you use NestJS or Express it's awesome, but for the rest of the frameworks it's terrible!\n   * That's why I have this method, just to try and create a raw request to be used and passed to the frameworks so they can handle the request\n   * as if they received the request from the native http module.\n   *\n   * @param request - The Express request\n   */\n  protected getRequestFromExpressRequest(\n    request: IncomingMessage,\n  ): ServerlessRequest {\n    const expressRequestParsed = request as unknown as {\n      body: object | Buffer;\n    };\n\n    const headers = getFlattenedHeadersMap(request.headers, ',', true);\n    const remoteAddress = headers['x-forwarded-for'];\n\n    let body: Buffer | undefined;\n\n    if (\n      expressRequestParsed.body &&\n      typeof expressRequestParsed.body === 'object'\n    ) {\n      const jsonContent = JSON.stringify(expressRequestParsed.body);\n\n      const [bufferBody, contentLength] = getEventBodyAsBuffer(\n        jsonContent,\n        false,\n      );\n\n      body = bufferBody;\n      headers['content-length'] = String(contentLength);\n    }\n\n    return new ServerlessRequest({\n      method: request.method!,\n      url: request.url!,\n      body,\n      headers,\n      remoteAddress,\n    });\n  }\n\n  //#endregion\n}\n"],"mappings":"gGAeO,IAAeA,EAAf,KAAgC,CAfvC,MAeuC,CAAAC,EAAA,mBAS3B,kBACRC,EACAC,EACqE,CACrE,MAAO,CAACC,EAA0BC,IAA6B,CAC7D,IAAMC,EAAgB,KAAK,6BAA6BF,CAAO,EAE/D,OAAOD,EAAU,YAAYD,EAAKI,EAAeD,CAAQ,CAC3D,CACF,CAYU,6BACRD,EACmB,CACnB,IAAMG,EAAuBH,EAIvBI,EAAUC,EAAuBL,EAAQ,QAAS,IAAK,EAAI,EAC3DM,EAAgBF,EAAQ,iBAAiB,EAE3CG,EAEJ,GACEJ,EAAqB,MACrB,OAAOA,EAAqB,MAAS,SACrC,CACA,IAAMK,EAAc,KAAK,UAAUL,EAAqB,IAAI,EAEtD,CAACM,EAAYC,CAAa,EAAIC,EAClCH,EACA,EACF,EAEAD,EAAOE,EACPL,EAAQ,gBAAgB,EAAI,OAAOM,CAAa,CAClD,CAEA,OAAO,IAAIE,EAAkB,CAC3B,OAAQZ,EAAQ,OAChB,IAAKA,EAAQ,IACb,KAAAO,EACA,QAAAH,EACA,cAAAE,CACF,CAAC,CACH,CAGF","names":["RawRequest","__name","app","framework","request","response","customRequest","expressRequestParsed","headers","getFlattenedHeadersMap","remoteAddress","body","jsonContent","bufferBody","contentLength","getEventBodyAsBuffer","ServerlessRequest"]}