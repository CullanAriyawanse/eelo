"use strict";var R=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var E=Object.getOwnPropertyNames;var T=Object.prototype.hasOwnProperty;var c=(r,e)=>R(r,"name",{value:e,configurable:!0});var d=(r,e)=>{for(var s in e)R(r,s,{get:e[s],enumerable:!0})},i=(r,e,s,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of E(e))!T.call(r,o)&&o!==s&&R(r,o,{get:()=>e[o],enumerable:!(t=u(e,o))||t.enumerable});return r};var C=r=>i(R({},"__esModule",{value:!0}),r);var S={};d(S,{CallbackResolver:()=>a});module.exports=C(S);var a=class{static{c(this,"CallbackResolver")}createResolver({callback:e,event:s,log:t,respondWithErrors:o,adapter:p}){if(!e)throw new Error('Could not figure out how to create the resolver because the "callback" argument was not sent.');let v={succeed:n=>e(null,n),fail:n=>e(n,null)};return{run:n=>{n().then(l=>v.succeed(l)).catch(l=>{t.error("SERVERLESS_ADAPTER:RESPOND_TO_EVENT_SOURCE_WITH_ERROR",l),p.onErrorWhileForwarding({delegatedResolver:v,error:l,log:t,event:s,respondWithErrors:o})})}}}};0&&(module.exports={CallbackResolver});
//# sourceMappingURL=index.cjs.map