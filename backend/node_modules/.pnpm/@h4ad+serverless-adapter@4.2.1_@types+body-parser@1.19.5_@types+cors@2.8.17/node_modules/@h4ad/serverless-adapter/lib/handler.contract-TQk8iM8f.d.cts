import { A as AdapterContract, R as ResolverContract } from './adapter.contract-y5xSjOjo.cjs';
import { F as FrameworkContract } from './framework.contract-YnJ-fl1w.cjs';
import { I as ILogger } from './logger-9me5n48P.cjs';

/**
 * The interface representing the binary settings implementation by function
 *
 * @breadcrumb Types / BinarySettings
 * @public
 */
interface BinarySettingsFunction {
    /**
     * This property can be a function that receives the response headers and returns whether that response should be encoded as binary.
     * Otherwise, you can specify not to treat any response as binary by putting `false` in this property.
     *
     * @remarks Setting this property prevents the `contentTypes` and `contentEncodings` properties from being used.
     */
    isBinary: ((headers: Record<string, string | string[] | undefined>) => boolean) | false;
}
/**
 * The interface representing the binary settings implementation by looking inside the headers
 *
 * @breadcrumb Types / BinarySettings
 * @public
 */
interface BinarySettingsContentHeaders {
    /**
     * The list of content types that will be treated as binary
     */
    contentTypes: string[];
    /**
     * The list of content encodings that will be treated as binary
     */
    contentEncodings: string[];
}
/**
 * The interface representing the settings for whether the response should be treated as binary or not
 *
 * @remarks Encoded as binary means the response body will be converted to base64
 *
 * @breadcrumb Types / BinarySettings
 * @public
 */
type BinarySettings = BinarySettingsFunction | BinarySettingsContentHeaders;

/**
 * The function used to handle serverless requests
 *
 * @breadcrumb Contracts / HandlerContract
 * @public
 */
type ServerlessHandler<TReturn> = (...args: any[]) => TReturn;
/**
 * The interface that represents the contract between the handler and the real implementation
 *
 * @breadcrumb Contracts / HandlerContract
 * @public
 */
interface HandlerContract<TApp, TEvent, TContext, TCallback, TResponse, TReturn> {
    /**
     * Get the handler that will handle serverless requests
     */
    getHandler(app: TApp, framework: FrameworkContract<TApp>, adapters: AdapterContract<TEvent, TContext, TResponse>[], resolverFactory: ResolverContract<TEvent, TContext, TCallback, TResponse, TReturn>, binarySettings: BinarySettings, respondWithErrors: boolean, log: ILogger): ServerlessHandler<TReturn>;
}

export type { BinarySettings as B, HandlerContract as H, ServerlessHandler as S, BinarySettingsFunction as a, BinarySettingsContentHeaders as b };
