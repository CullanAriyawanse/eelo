{"version":3,"sources":["../src/handlers/default/default.handler.ts"],"sourcesContent":["//#region Imports\n\nimport util from 'node:util';\nimport type { BinarySettings, SingleValueHeaders } from '../../@types';\nimport type {\n  AdapterContract,\n  AdapterRequest,\n  FrameworkContract,\n  ResolverContract,\n  ServerlessHandler,\n} from '../../contracts';\nimport {\n  BaseHandler,\n  type ILogger,\n  isBinary,\n  setCurrentInvoke,\n  waitForStreamComplete,\n} from '../../core';\nimport { ServerlessResponse } from '../../network';\n\n//#endregion\n\n/**\n * The class that implements a default serverless handler consisting of a function with event, context and callback parameters respectively\n *\n * @breadcrumb Handlers / DefaultHandler\n * @public\n */\nexport class DefaultHandler<\n  TApp,\n  TEvent,\n  TContext,\n  TCallback,\n  TResponse,\n  TReturn,\n> extends BaseHandler<TApp, TEvent, TContext, TCallback, TResponse, TReturn> {\n  //#region Public Methods\n\n  /**\n   * {@inheritDoc}\n   */\n  public getHandler(\n    app: TApp,\n    framework: FrameworkContract<TApp>,\n    adapters: AdapterContract<TEvent, TContext, TResponse>[],\n    resolverFactory: ResolverContract<\n      TEvent,\n      TContext,\n      TCallback,\n      TResponse,\n      TReturn\n    >,\n    binarySettings: BinarySettings,\n    respondWithErrors: boolean,\n    log: ILogger,\n  ): ServerlessHandler<TReturn> {\n    return (event: TEvent, context: TContext, callback?: TCallback) => {\n      this.onReceiveRequest(\n        log,\n        event,\n        context,\n        binarySettings,\n        respondWithErrors,\n      );\n\n      const adapter = this.getAdapterByEventAndContext(\n        event,\n        context,\n        adapters,\n        log,\n      );\n\n      this.onResolveAdapter(log, adapter);\n\n      setCurrentInvoke({ event, context });\n\n      const resolver = resolverFactory.createResolver({\n        event,\n        context,\n        callback,\n        log,\n        respondWithErrors,\n        adapter,\n      });\n\n      return resolver.run(() =>\n        this.forwardRequestToFramework(\n          app,\n          framework,\n          event,\n          context,\n          adapter,\n          binarySettings,\n          log,\n        ),\n      );\n    };\n  }\n\n  //#endregion\n\n  //#region Hooks\n\n  /**\n   * The hook executed on receive a request, before the request is being processed\n   *\n   * @param log - The instance of logger\n   * @param event - The event sent by serverless\n   * @param context - The context sent by serverless\n   * @param binarySettings - The binary settings\n   * @param respondWithErrors - Indicates whether the error stack should be included in the response or not\n   */\n  protected onReceiveRequest(\n    log: ILogger,\n    event: TEvent,\n    context: TContext,\n    binarySettings: BinarySettings,\n    respondWithErrors: boolean,\n  ): void {\n    log.debug('SERVERLESS_ADAPTER:PROXY', () => ({\n      event: util.inspect(event, { depth: null }),\n      context: util.inspect(context, { depth: null }),\n      binarySettings,\n      respondWithErrors,\n    }));\n  }\n\n  /**\n   * The hook executed after resolve the adapter that will be used to handle the request and response\n   *\n   * @param log - The instance of logger\n   * @param adapter - The adapter resolved\n   */\n  protected onResolveAdapter(\n    log: ILogger,\n    adapter: AdapterContract<TEvent, TContext, TResponse>,\n  ): void {\n    log.debug(\n      'SERVERLESS_ADAPTER:RESOLVED_ADAPTER_NAME: ',\n      adapter.getAdapterName(),\n    );\n  }\n\n  /**\n   * The hook executed after resolves the request values that will be sent to the framework\n   *\n   * @param log - The instance of logger\n   * @param requestValues - The request values returned by the adapter\n   */\n  protected onResolveRequestValues(\n    log: ILogger,\n    requestValues: AdapterRequest,\n  ): void {\n    log.debug(\n      'SERVERLESS_ADAPTER:FORWARD_REQUEST_TO_FRAMEWORK:REQUEST_VALUES',\n      () => ({\n        requestValues: {\n          ...requestValues,\n          body: requestValues.body?.toString(),\n        },\n      }),\n    );\n  }\n\n  /**\n   * The hook executed after handling the response sent by the framework\n   *\n   * @param log - The instance of logger\n   * @param response - The response sent by the framework\n   */\n  protected onResolveForwardedResponseToFramework(\n    log: ILogger,\n    response: ServerlessResponse,\n  ): void {\n    log.debug(\n      'SERVERLESS_ADAPTER:FORWARD_REQUEST_TO_FRAMEWORK:RESPONSE',\n      () => ({\n        response,\n      }),\n    );\n  }\n\n  /**\n   * The hook executed before sending response to the serverless\n   *\n   * @param log - The instance of logger\n   * @param statusCode - The status code of the response\n   * @param body - The body of the response\n   * @param headers - The headers of the response\n   * @param isBase64Encoded - Indicates whether the response was encoded as binary or not\n   */\n  protected onForwardResponse(\n    log: ILogger,\n    statusCode: number,\n    body: string,\n    headers: SingleValueHeaders,\n    isBase64Encoded: boolean,\n  ) {\n    log.debug(\n      'SERVERLESS_ADAPTER:FORWARD_RESPONSE:EVENT_SOURCE_RESPONSE_PARAMS',\n      () => ({\n        statusCode,\n        body,\n        headers,\n        isBase64Encoded,\n      }),\n    );\n  }\n\n  /**\n   * The hook executed before sending response to the serverless with response from adapter\n   *\n   * @param log - The instance of logger\n   * @param successResponse - The success response resolved by the adapter\n   * @param body - The body of the response sent by the framework\n   */\n  protected onForwardResponseAdapterResponse(\n    log: ILogger,\n    successResponse: TResponse,\n    body: string,\n  ) {\n    log.debug(\n      'SERVERLESS_ADAPTER:FORWARD_RESPONSE:EVENT_SOURCE_RESPONSE',\n      () => ({\n        successResponse: util.inspect(successResponse, { depth: null }),\n        body,\n      }),\n    );\n  }\n\n  //#endregion\n\n  //#region Protected Methods\n\n  /**\n   * The function to forward the event to the framework\n   *\n   * @param app - The instance of the app (express, hapi, etc...)\n   * @param framework - The framework that will process requests\n   * @param event - The event sent by serverless\n   * @param context - The context sent by serverless\n   * @param adapter - The adapter resolved to this event\n   * @param log - The instance of logger\n   * @param binarySettings - The binary settings\n   */\n  protected async forwardRequestToFramework(\n    app: TApp,\n    framework: FrameworkContract<TApp>,\n    event: TEvent,\n    context: TContext,\n    adapter: AdapterContract<TEvent, TContext, TResponse>,\n    binarySettings: BinarySettings,\n    log: ILogger,\n  ): Promise<TResponse> {\n    const requestValues = adapter.getRequest(event, context, log);\n\n    this.onResolveRequestValues(log, requestValues);\n\n    const [request, response] =\n      this.getServerlessRequestResponseFromAdapterRequest(requestValues);\n\n    framework.sendRequest(app, request, response);\n\n    await waitForStreamComplete(response);\n\n    this.onResolveForwardedResponseToFramework(log, response);\n\n    return this.forwardResponse(event, response, adapter, binarySettings, log);\n  }\n\n  /**\n   * The function to forward the response back to the serverless\n   *\n   * @param event - The event sent by serverless\n   * @param response - The response of the framework\n   * @param adapter - The adapter resolved to this event\n   * @param binarySettings - The binary settings\n   * @param log - The instance of logger\n   */\n  protected forwardResponse(\n    event: TEvent,\n    response: ServerlessResponse,\n    adapter: AdapterContract<TEvent, TContext, TResponse>,\n    binarySettings: BinarySettings,\n    log: ILogger,\n  ): TResponse {\n    const statusCode = response.statusCode;\n    const headers = ServerlessResponse.headers(response);\n    const isBase64Encoded = isBinary(headers, binarySettings);\n    const encoding = isBase64Encoded ? 'base64' : 'utf8';\n    const body = ServerlessResponse.body(response).toString(encoding);\n    const logBody = isBase64Encoded ? '[BASE64_ENCODED]' : body;\n\n    this.onForwardResponse(log, statusCode, logBody, headers, isBase64Encoded);\n\n    const successResponse = adapter.getResponse({\n      event,\n      statusCode,\n      body,\n      headers,\n      isBase64Encoded,\n      response,\n      log,\n    });\n\n    this.onForwardResponseAdapterResponse(log, successResponse, logBody);\n\n    return successResponse;\n  }\n\n  //#endregion\n}\n"],"mappings":"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","names":["util","DefaultHandler","BaseHandler","__name","app","framework","adapters","resolverFactory","binarySettings","respondWithErrors","log","event","context","callback","adapter","setCurrentInvoke","util","requestValues","response","statusCode","body","headers","isBase64Encoded","successResponse","request","waitForStreamComplete","ServerlessResponse","isBinary","encoding","logBody"]}