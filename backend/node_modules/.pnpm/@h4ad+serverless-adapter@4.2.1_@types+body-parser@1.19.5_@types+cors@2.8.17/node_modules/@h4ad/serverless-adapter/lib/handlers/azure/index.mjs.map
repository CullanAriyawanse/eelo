{"version":3,"sources":["../../../src/handlers/azure/azure.handler.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/unbound-method */\n//#region Imports\n\nimport type { Context } from '@azure/functions';\nimport type { BinarySettings } from '../../@types';\nimport type {\n  AdapterContract,\n  FrameworkContract,\n  ResolverContract,\n  ServerlessHandler,\n} from '../../contracts';\nimport {\n  type ILogger,\n  getDefaultIfUndefined,\n  isInternalLogger,\n} from '../../core';\nimport { DefaultHandler } from '../default';\n\n//#endregion\n\n/**\n * The options to customize {@link AzureHandler}\n *\n * @breadcrumb Handlers / AzureHandler\n * @public\n */\nexport interface AzureHandlerOptions {\n  /**\n   * Indicates to use the context log instead console.log when logger is internal (created by the library)\n   *\n   * @defaultValue true\n   */\n  useContextLogWhenInternalLogger: boolean;\n}\n\n/**\n * The class that implements a serverless handler for Azure Function.\n *\n * When you don't specify a custom logger, the {@link Context} logger is used instead.\n *\n * @breadcrumb Handlers / AzureHandler\n * @public\n */\nexport class AzureHandler<\n  TApp,\n  TEvent,\n  TCallback,\n  TResponse,\n  TReturn,\n> extends DefaultHandler<TApp, TEvent, Context, TCallback, TResponse, TReturn> {\n  //#region Constructor\n\n  /**\n   * Default Constructor\n   */\n  constructor(protected readonly options?: AzureHandlerOptions) {\n    super();\n  }\n\n  //#endregion\n\n  //#region Public Methods\n\n  /**\n   * {@inheritDoc}\n   */\n  public override getHandler(\n    app: TApp,\n    framework: FrameworkContract<TApp>,\n    adapters: AdapterContract<TEvent, Context, TResponse>[],\n    resolverFactory: ResolverContract<\n      TEvent,\n      Context,\n      TCallback,\n      TResponse,\n      TReturn\n    >,\n    binarySettings: BinarySettings,\n    respondWithErrors: boolean,\n    log: ILogger,\n  ): ServerlessHandler<TReturn> {\n    return (context: Context, event: TEvent) => {\n      const useContextLogWhenInternalLogger = getDefaultIfUndefined(\n        this.options?.useContextLogWhenInternalLogger,\n        true,\n      );\n\n      if (isInternalLogger(log) && useContextLogWhenInternalLogger)\n        log = this.createLoggerFromContext(context);\n\n      const defaultHandler = super.getHandler(\n        app,\n        framework,\n        adapters,\n        resolverFactory,\n        binarySettings,\n        respondWithErrors,\n        log,\n      );\n\n      // remove this from context\n      // because user can mess it-up the things\n      // @ts-ignore\n      delete context.done;\n      delete context.res;\n\n      return defaultHandler(event, context, undefined);\n    };\n  }\n\n  //#endregion\n\n  //#region Protected Methods\n\n  /**\n   * Get the {@link ILogger} instance from logger of the context\n   *\n   * @param context - The Azure Context\n   */\n  protected createLoggerFromContext(context: Context): ILogger {\n    return {\n      error: context.log.error,\n      debug: context.log.verbose,\n      verbose: context.log.verbose,\n      info: context.log.info,\n      warn: context.log.warn,\n    };\n  }\n\n  //#endregion\n}\n"],"mappings":"8IA2CO,IAAMA,EAAN,cAMGC,CAAqE,CAM7E,YAA+BC,EAA+B,CAC5D,MAAM,EADuB,aAAAA,CAE/B,CAzDF,MAiD+E,CAAAC,EAAA,qBAiB7D,WACdC,EACAC,EACAC,EACAC,EAOAC,EACAC,EACAC,EAC4B,CAC5B,MAAO,CAACC,EAAkBC,IAAkB,CAC1C,IAAMC,EAAkCC,EACtC,KAAK,SAAS,gCACd,EACF,EAEIC,EAAiBL,CAAG,GAAKG,IAC3BH,EAAM,KAAK,wBAAwBC,CAAO,GAE5C,IAAMK,EAAiB,MAAM,WAC3BZ,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,CACF,EAKA,cAAOC,EAAQ,KACf,OAAOA,EAAQ,IAERK,EAAeJ,EAAOD,EAAS,MAAS,CACjD,CACF,CAWU,wBAAwBA,EAA2B,CAC3D,MAAO,CACL,MAAOA,EAAQ,IAAI,MACnB,MAAOA,EAAQ,IAAI,QACnB,QAASA,EAAQ,IAAI,QACrB,KAAMA,EAAQ,IAAI,KAClB,KAAMA,EAAQ,IAAI,IACpB,CACF,CAGF","names":["AzureHandler","DefaultHandler","options","__name","app","framework","adapters","resolverFactory","binarySettings","respondWithErrors","log","context","event","useContextLogWhenInternalLogger","getDefaultIfUndefined","isInternalLogger","defaultHandler"]}